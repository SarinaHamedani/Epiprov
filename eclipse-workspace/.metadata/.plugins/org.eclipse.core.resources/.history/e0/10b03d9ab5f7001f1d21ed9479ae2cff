/*
 * generated by Xtext 2.37.0
 */
package org.xtext.geodes.trustdsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.geodes.trustdsl.trustDSL.UncertainElement
import org.xtext.geodes.trustdsl.trustDSL.SBoolean
import java.math.RoundingMode
import java.util.List
import java.math.BigDecimal
import java.util.Collection
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TrustDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val sb = new StringBuilder

        // Process each UncertainElement in the model
        for (element : resource.allContents.filter(typeof(UncertainElement)).toList) {
            sb.append(generateFusionElement(element))
        }

        sb.append("}\n")

        // Write output to .trustdsl file
        fsa.generateFile("generated.trustdsl", sb.toString)
    }

    def String generateFusionElement(UncertainElement element) {
        val sb = new StringBuilder
        val fusionName = element.name + "_Fusion"
        val beliefs = element.beliefs.map[it.opinion].toList

        sb.append("UncertainElementFusion " + fusionName + " {")
        sb.append("\n    beliefs {")
        
        // Copy over beliefs
//        for (belief : element.beliefs) {
//            sb.append("\n        " + belief.name + " (" + belief.agent.name + ", " + formatSBoolean(belief.opinion) + "),")
//        }
//        sb.deleteCharAt(sb.length - 1) // Remove last comma
//        sb.append("\n    }")

        // Compute fusion values
        val aleatoryCumulativeBF = computeAleatoryCumulativeBF(beliefs)
//        val averagingBF = computeAveragingBF(beliefs)
//        val beliefConstraintFusion = computeBeliefConstraintFusion(beliefs)
//        val consensusCompromiseBF = computeConsensusCompromiseBF(beliefs)
//        val epistemicCumulativeBF = computeEpistemicCumulativeBF(beliefs)
//        val weightedBF = computeWeightedBF(beliefs)

        // Append fusion results
        sb.append("\n        aleatoryCumulativeBF = " + aleatoryCumulativeBF)
        println("[DEBUG] aleatoryCumulativeBF: " + aleatoryCumulativeBF)
//        sb.append("\n    averageingBF = " + averagingBF)
//        sb.append("\n    beliefConstraintFusion = " + beliefConstraintFusion)
//        sb.append("\n    consensusCompromiseBF = " + consensusCompromiseBF)
//        sb.append("\n    epistemicCumulativeBF = " + epistemicCumulativeBF)
//        sb.append("\n    weightedBF = " + weightedBF)
        sb.append("\n    }\n")

        return sb.toString
    }

//    def String formatSBoolean(SBoolean sBoolean) {
//        return "(" + round(sBoolean.belief) + ", " + round(sBoolean.disbelief) + ", " + round(sBoolean.uncertainty) + ", " + round(sBoolean.baseRate) + ")"
//    }

    def double round(double value) {
        return BigDecimal.valueOf(value).setScale(2, RoundingMode.HALF_UP).doubleValue()
    }

    /** Fusion Operator: Aleatory Cumulative Belief Fusion (ACBF) **/
    def String computeAleatoryCumulativeBF(Collection<SBoolean> opinions) {
	    // Handle edge cases
        if (opinions === null || opinions.contains(null) || opinions.empty) {
            throw new IllegalArgumentException("aCBF: Cannot average null opinions")
        }

        if (opinions.size == 1) {
            return opinions.iterator.next.toString()
        }
        
        // Fusion as defined by Jøsang
        var double resultBelief = 0.0
        var double resultDisbelief = 0.0
        var double resultUncertainty = 0.0
        var double resultRelativeWeight = 0.0
        var double resultAtomicity = -1.0

        val dogmatic = new ArrayList<SBoolean>(opinions.size)
        val it = opinions.iterator
        var boolean first = true

        while (it.hasNext) {
            val o = it.next
            if (first) {
                resultAtomicity = o.baseRate
                first = false
            }
            // Dogmatic iff uncertainty is zero
            if (o.uncertainty == 0.0) {
                dogmatic.add(o)
            }
        }

        if (dogmatic.empty) {
            // No dogmatic opinions: Compute fusion using Equation 16 of Jøsang’s paper
            val productOfUncertainties = opinions.map[o | o.uncertainty].reduce[acc, u | acc * u]

            var double numerator = 0.0
            var double beliefAccumulator = 0.0
            var double disbeliefAccumulator = 0.0

            // Compute belief fusion values
            for (o : opinions) {
                val productWithoutO = productOfUncertainties / o.uncertainty
                beliefAccumulator += productWithoutO * o.belief
                disbeliefAccumulator += productWithoutO * o.disbelief
                numerator += productWithoutO
            }

            // Complete the numerator
            numerator -= (opinions.size - 1) * productOfUncertainties

            // Compute final fusion values
            resultBelief = beliefAccumulator / numerator
            resultDisbelief = disbeliefAccumulator / numerator
            resultUncertainty = productOfUncertainties / numerator
            resultRelativeWeight = 0.0
        } else {
            // At least 1 dogmatic opinion: Compute fusion using Equation 17
            val totalWeight = dogmatic.map[o | o.getRelativeWeight].reduce[acc, v | acc + v]

            resultBelief = dogmatic.map[o | o.getRelativeWeight / totalWeight * o.belief].reduce[acc, v | acc + v]
            resultDisbelief = dogmatic.map[o | o.getRelativeWeight / totalWeight * o.disbelief].reduce[acc, v | acc + v]
            resultUncertainty = 0.0
            resultRelativeWeight = totalWeight
        }

		
	    return "(" + round(resultBelief) + 
	           ", " + round(resultDisbelief) +
	           ", " + round(resultUncertainty) +
	           ", " + resultAtomicity + ")"
	}
	
	def double getRelativeWeight(SBoolean t) {
        return t.isDogmatic? 1.0D : 0.0D;
    }
    
    def boolean isDogmatic(SBoolean t) {
	    return t.uncertainty == 0.0D;
	}

    /** Fusion Operator: Averaging Belief Fusion (ABF) **/
//    def SBoolean computeAveragingBF(List<SBoolean> beliefs) {
//        val avgBelief = beliefs.map[it.belief].average
//        val avgDisbelief = beliefs.map[it.disbelief].average
//        val avgUncertainty = beliefs.map[it.uncertainty].average
//        val baseRate = beliefs.get(0).baseRate
//
//        return new SBoolean(round(avgBelief), round(avgDisbelief), round(avgUncertainty), baseRate)
//    }
//
//    /** Fusion Operator: Belief Constraint Fusion (BCF) **/
//    def SBoolean computeBeliefConstraintFusion(List<SBoolean> beliefs) {
//        val maxBelief = beliefs.map[it.belief].max
//        val minDisbelief = beliefs.map[it.disbelief].min
//        val uncertainty = 1 - (maxBelief + minDisbelief)
//        val baseRate = beliefs.get(0).baseRate
//
//        return new SBoolean(round(maxBelief), round(minDisbelief), round(uncertainty), baseRate)
//    }
//
//    /** Fusion Operator: Consensus & Compromise Fusion (CCF) **/
//    def SBoolean computeConsensusCompromiseBF(List<SBoolean> beliefs) {
//        val totalWeight = beliefs.size
//        val weightedBelief = beliefs.map[it.belief].sum / totalWeight
//        val weightedDisbelief = beliefs.map[it.disbelief].sum / totalWeight
//        val weightedUncertainty = beliefs.map[it.uncertainty].sum / totalWeight
//        val baseRate = beliefs.get(0).baseRate
//
//        return new SBoolean(round(weightedBelief), round(weightedDisbelief), round(weightedUncertainty), baseRate)
//    }
//
//    /** Fusion Operator: Epistemic Cumulative Belief Fusion (ECBF) **/
//    def SBoolean computeEpistemicCumulativeBF(List<SBoolean> beliefs) {
//        val minBelief = beliefs.map[it.belief].min
//        val maxDisbelief = beliefs.map[it.disbelief].max
//        val uncertainty = 1 - (minBelief + maxDisbelief)
//        val baseRate = beliefs.get(0).baseRate
//
//        return new SBoolean(round(minBelief), round(maxDisbelief), round(uncertainty), baseRate)
//    }
//
//    /** Fusion Operator: Weighted Belief Fusion (WBF) **/
//    def SBoolean computeWeightedBF(List<SBoolean> beliefs) {
//        val totalWeight = beliefs.map[it.uncertainty].sum
//        val weightedBelief = beliefs.map[it.belief * (1 - it.uncertainty)].sum / totalWeight
//        val weightedDisbelief = beliefs.map[it.disbelief * (1 - it.uncertainty)].sum / totalWeight
//        val weightedUncertainty = beliefs.map[it.uncertainty].sum / totalWeight
//        val baseRate = beliefs.get(0).baseRate
//
//        return new SBoolean(round(weightedBelief), round(weightedDisbelief), round(weightedUncertainty), baseRate)
//    }
}
