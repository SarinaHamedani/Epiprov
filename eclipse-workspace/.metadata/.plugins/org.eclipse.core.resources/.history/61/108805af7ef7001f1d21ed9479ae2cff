/*
 * generated by Xtext 2.37.0
 */
package org.w3.ns.prov.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
//import org.w3.ns.prov.provN.Entity
//import org.w3.ns.prov.provN.Document
//import org.eclipse.xtend2.lib.StringConcatenation
import java.util.Random

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class ProvNGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// Assume the root element of the PROV-N file is a Document.
        val doc = resource.contents.head as Document
        val sb = new StringConcatenation

//         Generate Agent definitions.
        sb.append("Agent Expert1")
        sb.newLine
        sb.append("Agent Expert2")
        sb.newLine
        sb.newLine

        // Create a Random instance for generating random numbers.
//        val rand = new Random()
        
		// Iterate over the statements in the PROV-N model.
		doc.name.statements.apply(String stmt | println(stmt))
//		for (stmt : doc.name.statements) {
//			if (stmt instanceof Entity) {
//				val entity = stmt as Entity
//                // Look for an attribute with label "prov:value"
//                val valueAttr = IterableExtensions.head(entity.attributes.filter[ a | a.label == "prov:value" ])
//                if (valueAttr !== null) {
//                    val paramValue = Double.parseDouble(valueAttr.value)
//                    // Extract the local name (if the entity name contains a colon, e.g., "prov:beta")
//                    val localName = if(entity.name.contains(":")) entity.name.substring(entity.name.indexOf(":") + 1) else entity.name
//                    
//                    // Begin UncertainElement block.
//                    sb.append("UncertainElement " + localName + " {")
//                    sb.newLine
//                    sb.append("    beliefs {")
//                    sb.newLine
//                    
//                    // Generate Belief for Expert1.
//                    val beliefName1 = "Expert1_" + localName
//                    val belief1 = generateBelief(beliefName1, "Expert1", rand, paramValue)
//                    sb.append("            " + belief1)
//                    // Add a comma if more than one belief is generated.
//                    sb.append(",")
//                    sb.newLine
//                    
//                    // Generate Belief for Expert2.
//                    val beliefName2 = "Expert2_" + localName
//                    val belief2 = generateBelief(beliefName2, "Expert2", rand, paramValue)
//                    sb.append("            " + belief2)
//                    sb.newLine
//                    
//                    sb.append("}")
//                    sb.newLine
//                    sb.newLine
//                    
//                    }
//                    
//                 }
//		}
		
	}
	
	def String generateBelief(String beliefName, String agentName, Random rand, double baseRate) {
        val belief = rand.nextDouble
        val disbelief = rand.nextDouble
        val uncertainty = rand.nextDouble
        return "Belief " + beliefName + " (" + agentName + ", (" + belief.toString + ", " + disbelief.toString + ", " + uncertainty.toString + ", " + baseRate.toString + "))"
    }
        

    // Helper method to retrieve an attribute value from an Entity given a label.
//    private static String getAttributeValue(Entity entity, String attributeLabel) {
//        for (Attribute attr : entity.getAttributes()) {
//            // attr.getLabel() returns a string produced by the QualifiedName datatype rule.
//            if (attr.getLabel().equals(attributeLabel)) {
//                return attr.getValue();
//            }
//        }
//        return null;
//    }
//
//    // Looks up an UncertainElement by name; if not found, creates one.
//    private static UncertainElement findOrCreateUncertainElement(UncertaintyModel uncertaintyModel, String name) {
//        for (UncertainElement ue : uncertaintyModel.getUncertainElements()) {
//            if (ue.getName().equals(name)) {
//                return ue;
//            }
//        }
//        UncertainElement newUE = UncertaintyFactory.eINSTANCE.createUncertainElement();
//        newUE.setName(name);
//        uncertaintyModel.getUncertainElements().add(newUE);
//        return newUE;
//    }
//
//    // Example fusion operator: compute consensus as a simple average of the base value and any additional opinions.
//    private static double computeConsensus(UncertainElement ue) {
//        double base = ue.getBaseValue();
//        List<Double> opinions = ue.getOpinions(); // Assume getOpinions() returns a list of Double values.
//        if (opinions == null || opinions.isEmpty()) {
//            return base;
//        }
//        double sum = base;
//        for (Double opinion : opinions) {
//            sum += opinion;
//        }
//        return sum / (opinions.size() + 1);
//    }
}

