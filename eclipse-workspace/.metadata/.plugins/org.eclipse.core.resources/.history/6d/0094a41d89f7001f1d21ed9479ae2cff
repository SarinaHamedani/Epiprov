/*
 * generated by Xtext 2.37.0
 */
package org.w3.ns.prov.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.w3.ns.prov.provN.Entity
import org.w3.ns.prov.provN.Document
import org.eclipse.xtend2.lib.StringConcatenation
import java.util.Random
import java.math.BigDecimal
import java.math.RoundingMode

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class ProvNGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val doc = resource.contents.head as Document
        val sb = new StringConcatenation

        sb.append("Agent Expert1")
        sb.newLine
        sb.append("Agent Expert2")
        sb.newLine
        sb.newLine

        // Create a Random instance for generating random numbers.
        val rand = new Random()
		for (stmt : doc.name.statements) {
			if (stmt instanceof Entity) {
				val entity = stmt as Entity
				val valueAttr = IterableExtensions.head(entity.attributes.filter[ a | a.label == "prov:value" ])
                if (valueAttr !== null) {
                    val paramValue = Double.parseDouble(valueAttr.value)
                    val localName = if(entity.name.contains(":")) entity.name.substring(entity.name.indexOf(":") + 1) else entity.name
                    
                    sb.append("UncertainElement " + localName + " {")
                    sb.newLine
                    sb.append("    beliefs {")
                    sb.newLine
                    
                    val beliefName1 = "Expert1_" + localName
                    val belief1 = generateBelief(beliefName1, "Expert1", rand, paramValue)
                    sb.append("        " + belief1)
                    sb.append(",")
                    sb.newLine
                    
                    val beliefName2 = "Expert2_" + localName
                    val belief2 = generateBelief(beliefName2, "Expert2", rand, paramValue)
                    sb.append("        " + belief2)
                    sb.newLine
                    sb.append("    }")
                    sb.newLine
                    
                    sb.append("}")
                    sb.newLine
                    sb.newLine
				}		
			}
		}
	
    // Generate the .trustdsl file
    fsa.generateFile("ontario.trustdsl", sb.toString());	
		
	}
	
    
    def String generateBelief(String beliefName, String agentName, Random rand, double baseRate) {
        var belief = rand.nextDouble();
        var uncertainty = rand.nextDouble(1 - belief); 
        var disbelief = 1 - belief - uncertainty;

        belief = round(belief, 2);
        disbelief = round(disbelief, 2);
        uncertainty = round(uncertainty, 2);

        // Adjust the numbers to ensure their sum is exactly 1
        val total = belief + disbelief + uncertainty;
        if (total != 1.0) {
            val difference = 1.0 - total;
            disbelief += difference;
            disbelief = round(disbelief, 2);
        }

        return "Belief " + beliefName + " (" + agentName + ", (" + belief + ", " + disbelief + ", " + uncertainty + ", " + baseRate + "))";
    }

    def double round(double value, int places) {
        if (places < 0) throw new IllegalArgumentException();
        var bd = BigDecimal.valueOf(value);
        bd = bd.setScale(places, RoundingMode.HALF_UP);
        return bd.doubleValue();
    }
}