/*
 * generated by Xtext 2.37.0
 */
package org.xtext.geodes.trustdsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.geodes.trustdsl.trustDSL.UncertainElement
import org.xtext.geodes.trustdsl.trustDSL.SBoolean
import java.math.RoundingMode
import java.math.BigDecimal
import java.util.Collection
import java.util.ArrayList
import org.xtext.geodes.trustdsl.trustDSL.TrustDSLFactory

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TrustDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val sb = new StringBuilder

        // Process each UncertainElement in the model
        for (element : resource.allContents.filter(typeof(UncertainElement)).toList) {
            sb.append(generateFusionElement(element))
        }

        // Write output to .trustdsl file
        fsa.generateFile("generated.trustdsl", sb.toString)
    }

    def String generateFusionElement(UncertainElement element) {
        val sb = new StringBuilder
        val fusionName = element.name + "_Fusion"
        val beliefs = element.beliefs.map[it.opinion].toList

        sb.append("UncertainElementFusion " + fusionName + " {")
        sb.append("\n    beliefs {")
        
        // Copy over beliefs
        for (belief : element.beliefs) {
            sb.append("\n        Belief " + belief.name + " (" + belief.agent.name + ", " + formatSBoolean(belief.opinion) + "),")
        }
        sb.deleteCharAt(sb.length - 1) // Remove last comma
        sb.append("\n    }")

        // Compute fusion values
        val aleatoryCumulativeBF = computeAleatoryCumulativeBF(beliefs)
        val averagingBF = computeAveragingBF(beliefs)
        val beliefConstraintFusion = computeBeliefConstraintFusion(beliefs)
//        val consensusCompromiseBF = computeConsensusCompromiseBF(beliefs)
//        val epistemicCumulativeBF = computeEpistemicCumulativeBF(beliefs)
//        val weightedBF = computeWeightedBF(beliefs)

        // Append fusion results
        sb.append("\n    aleatoryCumulativeBF = " + aleatoryCumulativeBF)
        sb.append("\n    averageingBF = " + averagingBF)
        sb.append("\n    beliefConstraintFusion = " + beliefConstraintFusion)
//        sb.append("\n    consensusCompromiseBF = " + consensusCompromiseBF)
//        sb.append("\n    epistemicCumulativeBF = " + epistemicCumulativeBF)
//        sb.append("\n    weightedBF = " + weightedBF)
        sb.append("\n}\n\n")

        return sb.toString
    }

    def static String formatSBoolean(SBoolean sBoolean) {
        return "(" + round(sBoolean.belief) + ", " + round(sBoolean.disbelief) + ", " + round(sBoolean.uncertainty) + ", " + sBoolean.baseRate + ")"
    }

    def static double round(double value) {
        return BigDecimal.valueOf(value).setScale(3, RoundingMode.HALF_UP).doubleValue()
    }

    /** Fusion Operator: Aleatory Cumulative Belief Fusion (ACBF) **/
    def static String computeAleatoryCumulativeBF(Collection<SBoolean> opinions) {
	    if (opinions === null || opinions.contains(null) || opinions.empty) {
            throw new IllegalArgumentException("aCBF: Cannot average null opinions")
        }

        if (opinions.size == 1) {
            return opinions.iterator.next.toString()
        }
        
        // Fusion as defined by Jøsang
        var double resultBelief = 0.0
        var double resultDisbelief = 0.0
        var double resultUncertainty = 0.0
        var double resultRelativeWeight = 0.0
        var double resultAtomicity = -1.0

        val dogmatic = new ArrayList<SBoolean>(opinions.size)
        val it = opinions.iterator
        var boolean first = true

        while (it.hasNext) {
            val o = it.next
            if (first) {
                resultAtomicity = o.baseRate
                first = false
            }
            // Dogmatic iff uncertainty is zero
            if (o.uncertainty == 0.0) {
                dogmatic.add(o)
            }
        }

        if (dogmatic.empty) {
            // No dogmatic opinions: Compute fusion using Equation 16 of Jøsang’s paper
            val productOfUncertainties = opinions.map[o | o.uncertainty].reduce[acc, u | acc * u]

            var double numerator = 0.0
            var double beliefAccumulator = 0.0
            var double disbeliefAccumulator = 0.0

            // Compute belief fusion values
            for (o : opinions) {
                val productWithoutO = productOfUncertainties / o.uncertainty
                beliefAccumulator += productWithoutO * o.belief
                disbeliefAccumulator += productWithoutO * o.disbelief
                numerator += productWithoutO
            }

            numerator -= (opinions.size - 1) * productOfUncertainties

            resultBelief = beliefAccumulator / numerator
            resultDisbelief = disbeliefAccumulator / numerator
            resultUncertainty = productOfUncertainties / numerator
            resultRelativeWeight = 0.0
        } else {
            // At least 1 dogmatic opinion: Compute fusion using Equation 17
            val totalWeight = dogmatic.map[o | o.getRelativeWeight].reduce[acc, v | acc + v]

            resultBelief = dogmatic.map[o | o.getRelativeWeight / totalWeight * o.belief].reduce[acc, v | acc + v]
            resultDisbelief = dogmatic.map[o | o.getRelativeWeight / totalWeight * o.disbelief].reduce[acc, v | acc + v]
            resultUncertainty = 0.0
            resultRelativeWeight = totalWeight
        }

		
	    return "(" + round(resultBelief) + 
	           ", " + round(resultDisbelief) +
	           ", " + round(resultUncertainty) +
	           ", " + round(resultAtomicity) + ")"
	}
	
	/** Fusion Operator: Averaging Belief Fusion (ABF) **/
	def static String computeAveragingBF(Collection<SBoolean> opinions) {
	    // Check for null or empty collections
	    if (opinions === null || opinions.contains(null) || opinions.empty) {
	        throw new IllegalArgumentException("AVF: Cannot average null opinions")
	    }
	
	    var double b = 0.0
	    var double u = 0.0
	    var double a = 0.0
	    var double PU = 1.0
	    var int count = 0
	
	    // Compute product of all uncertainties
	    PU = opinions.map[it.uncertainty].reduce[acc, v | acc * v]
	
	    // Case I: All opinions have uncertainty > 0
	    if (PU != 0.0) {
	        for (o : opinions) {
	            u += PU / o.uncertainty
	            b += o.belief * (PU / o.uncertainty)
	            a += o.baseRate
	        }
	        val oBelief = b / u
	        val oAtomicity = a / opinions.size
	        val oUncertainty = opinions.size * PU / u
	        val oDisbelief = 1.0 - oBelief - oUncertainty
	        
	        return "(" + oBelief + 
	           ", " + oDisbelief +
	           ", " + oUncertainty +
	           ", " + oAtomicity + ")"
	           
	    } else {
	        // Case II: At least one opinion has uncertainty = 0, so we only consider those
	        for (o : opinions.filter[it.uncertainty == 0.0]) {
	            b += o.belief
	            a += o.baseRate
	            count++
	        }
	        val oBelief = b / count
	        val oAtomicity = a / count
	        val oUncertainty = 0.0
	        val oDisbelief = 1.0 - oBelief - oUncertainty
	        
			return "(" + round(oBelief) + 
	           ", " + round(oDisbelief) +
	           ", " + round(oUncertainty) +
	           ", " + round(oAtomicity) + ")"
	    }
	}
	
	/** Fusion Operator: Belief Constraint Fusion (BCF) **/
	def static String computeBeliefConstraintFusion(Collection<SBoolean> opinions) {
	    if (opinions.contains(null) || opinions.size < 2) {
	        throw new IllegalArgumentException("BCF: Cannot fuse null opinions, or only one opinion was passed")
	    }
	
	    var SBoolean bcf = null
	
	    for (so : opinions) {
	        if (bcf === null) {
	            bcf = so
	        } else {
	            bcf = bcFusion(bcf, so)
	        }
	        if (bcf === null) {
	            return formatSBoolean(bcf)
	        }
	    }
	    return formatSBoolean(bcf)
	}
	
	
	/** Fusion Operator: Epistemic Cumulative Belief Fusion (ECBF) **/
	def static String epistemicCumulativeBeliefFusion(Collection<SBoolean> opinions) {
	    if (opinions === null || opinions.contains(null) || opinions.empty) {
	        throw new IllegalArgumentException("eCBF: Cannot average null opinions")
	    }
	
	    if (opinions.size == 1) {
	        return formatSBoolean(opinions.iterator.next.uncertaintyMaximized)
	    }
	
	    var double resultBelief = 0.0
	    var double resultDisbelief = 0.0
	    var double resultUncertainty = 0.0
	    var double resultRelativeWeight = 0.0
	    var double resultAtomicity = -1.0
	
	    val dogmatic = newArrayList
	    val iterator = opinions.iterator
	    var boolean first = true
	
	    while (iterator.hasNext) {
	        val o = iterator.next // .uncertaintyMaximized()
	        if (first) {
	            resultAtomicity = o.baseRate
	            first = false
	        }
	        // Dogmatic iff uncertainty is zero.
	        if (o.uncertainty == 0.0) {
	            dogmatic.add(o)
	        }
	    }
	
	    if (dogmatic.empty) {
	        // No dogmatic opinions: Case I/Eq16 from Jøsang’s paper
	        val productOfUncertainties = opinions.map[o.uncertainty].reduce[acc, u | acc * u]
	
	        var double numerator = 0.0
	        var double beliefAccumulator = 0.0
	        var double disbeliefAccumulator = 0.0
	
	        // Compute the top and bottom sums in Eq16
	        for (o : opinions) {
	            val productWithoutO = productOfUncertainties / o.uncertainty
	            beliefAccumulator += productWithoutO * o.belief
	            disbeliefAccumulator += productWithoutO * o.disbelief
	            numerator += productWithoutO
	        }
	
	        // Complete the numerator
	        numerator -= (opinions.size - 1) * productOfUncertainties
	
	        // Compute final fusion values
	        resultBelief = beliefAccumulator / numerator
	        resultDisbelief = disbeliefAccumulator / numerator
	        resultUncertainty = productOfUncertainties / numerator
	        resultRelativeWeight = 0.0
	    } else {
	        // At least one dogmatic opinion
	        val totalWeight = dogmatic.map[o.relativeWeight].reduce[acc, w | acc + w]
	
	        resultBelief = dogmatic.map[o | (o.relativeWeight / totalWeight) * o.belief].reduce[acc, v | acc + v]
	        resultDisbelief = dogmatic.map[o | (o.relativeWeight / totalWeight) * o.disbelief].reduce[acc, v | acc + v]
	        resultUncertainty = 0.0
	        resultRelativeWeight = totalWeight
	    }
	
	    // Use EMF factory to create an instance of SBoolean
	    val result = createSBoolean(resultBelief, resultDisbelief, resultUncertainty, resultAtomicity)
	
	    return formatSBoolean(result.uncertaintyMaximized)
	}
	
	def static SBoolean uncertaintyMaximized(SBoolean self) {
	    val double p = self.projection
	
	    // Extreme cases
	    if ((self.baseRate == 1.0 && p == 1.0) || (self.baseRate == 1.0 && self.uncertainty == 1.0) || (self.baseRate == 0.0 && self.belief == 0.0)) {
	        return createSBoolean(0.0, 0.0, 1.0, self.baseRate)
	    }
	
	    // Normal cases
	    if (p < self.baseRate) {
	        return createSBoolean(0.0, 1.0 - (p / self.baseRate), p / self.baseRate, self.baseRate)
	    }
	
	    return createSBoolean((p - self.baseRate) / (1.0 - self.baseRate), 0.0, (1.0 - p) / (1.0 - self.baseRate), self.baseRate)
	}
	
	
	def static SBoolean createSBoolean(double b, double d, double u, double a) {
	    val result = TrustDSLFactory.eINSTANCE.createSBoolean()
	    result.setBelief(b)
	    result.setDisbelief(d)
	    result.setUncertainty(u)
	    result.setBaseRate(a)
	    return result
	}
	
	def final static SBoolean bcFusion(SBoolean bcf, SBoolean opinion) {
    // Implemented using equation 12.2 of Jøsang's book
	    val double harmony = bcf.belief * opinion.uncertainty + 
	                         bcf.uncertainty * opinion.belief + 
	                         bcf.belief * opinion.belief
	
	    val double conflict = bcf.belief * opinion.disbelief + 
	                          bcf.disbelief * opinion.belief
	
	    if (conflict == 1.0) {
	        return null
	    }
	
	    val double b = harmony / (1.0 - conflict)
	    val double u = (bcf.uncertainty * opinion.uncertainty) / (1.0 - conflict)
	
	    val double a = if (bcf.uncertainty + opinion.uncertainty == 2.0)
	        (bcf.baseRate + opinion.baseRate) / 2.0
	    else
	        (bcf.baseRate * (1.0 - bcf.uncertainty) + 
	         opinion.baseRate * (1.0 - opinion.uncertainty)) / (2 - bcf.uncertainty - opinion.uncertainty)
		val result = TrustDSLFactory.eINSTANCE.createSBoolean()
	    result.setBelief(b)
	    result.setDisbelief(1.0 - b - u)
	    result.setUncertainty(u)
	    result.setBaseRate(a)
	    return result
	}
	
	
	def static double getRelativeWeight(SBoolean t) {
        return t.isDogmatic? 1.0D : 0.0D;
    }
    
    def static boolean isDogmatic(SBoolean t) {
	    return t.uncertainty == 0.0D;
	}

}
