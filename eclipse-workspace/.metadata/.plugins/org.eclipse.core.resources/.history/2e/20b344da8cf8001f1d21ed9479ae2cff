/*
 * generated by Xtext 2.37.0
 */
package org.xtext.geodes.trustdsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.geodes.trustdsl.trustDSL.UncertainElement
import org.xtext.geodes.trustdsl.trustDSL.SBoolean
import java.math.RoundingMode
import java.math.BigDecimal
import java.util.Collection
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TrustDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val sb = new StringBuilder

        // Process each UncertainElement in the model
        for (element : resource.allContents.filter(typeof(UncertainElement)).toList) {
            sb.append(generateFusionElement(element))
        }

        // Write output to .trustdsl file
        fsa.generateFile("generated.trustdsl", sb.toString)
    }

    def String generateFusionElement(UncertainElement element) {
        val sb = new StringBuilder
        val fusionName = element.name + "_Fusion"
        val beliefs = element.beliefs.map[it.opinion].toList

        sb.append("UncertainElementFusion " + fusionName + " {")
        sb.append("\n    beliefs {")
        
        // Copy over beliefs
        for (belief : element.beliefs) {
            sb.append("\n        Belief " + belief.name + " (" + belief.agent.name + ", " + formatSBoolean(belief.opinion) + "),")
        }
        sb.deleteCharAt(sb.length - 1) // Remove last comma
        sb.append("\n    }")

        // Compute fusion values
        val aleatoryCumulativeBF = computeAleatoryCumulativeBF(beliefs)
        val averagingBF = computeAveragingBF(beliefs)
//        val beliefConstraintFusion = computeBeliefConstraintFusion(beliefs)
//        val consensusCompromiseBF = computeConsensusCompromiseBF(beliefs)
//        val epistemicCumulativeBF = computeEpistemicCumulativeBF(beliefs)
//        val weightedBF = computeWeightedBF(beliefs)

        // Append fusion results
        sb.append("\n    aleatoryCumulativeBF = " + aleatoryCumulativeBF)
        sb.append("\n    averageingBF = " + averagingBF)
//        sb.append("\n    beliefConstraintFusion = " + beliefConstraintFusion)
//        sb.append("\n    consensusCompromiseBF = " + consensusCompromiseBF)
//        sb.append("\n    epistemicCumulativeBF = " + epistemicCumulativeBF)
//        sb.append("\n    weightedBF = " + weightedBF)
        sb.append("\n}\n\n")

        return sb.toString
    }

    def String formatSBoolean(SBoolean sBoolean) {
        return "(" + round(sBoolean.belief) + ", " + round(sBoolean.disbelief) + ", " + round(sBoolean.uncertainty) + ", " + sBoolean.baseRate + ")"
    }

    def static double round(double value) {
        return BigDecimal.valueOf(value).setScale(3, RoundingMode.HALF_UP).doubleValue()
    }

    /** Fusion Operator: Aleatory Cumulative Belief Fusion (ACBF) **/
    def static String computeAleatoryCumulativeBF(Collection<SBoolean> opinions) {
	    if (opinions === null || opinions.contains(null) || opinions.empty) {
            throw new IllegalArgumentException("aCBF: Cannot average null opinions")
        }

        if (opinions.size == 1) {
            return opinions.iterator.next.toString()
        }
        
        // Fusion as defined by Jøsang
        var double resultBelief = 0.0
        var double resultDisbelief = 0.0
        var double resultUncertainty = 0.0
        var double resultRelativeWeight = 0.0
        var double resultAtomicity = -1.0

        val dogmatic = new ArrayList<SBoolean>(opinions.size)
        val it = opinions.iterator
        var boolean first = true

        while (it.hasNext) {
            val o = it.next
            if (first) {
                resultAtomicity = o.baseRate
                first = false
            }
            // Dogmatic iff uncertainty is zero
            if (o.uncertainty == 0.0) {
                dogmatic.add(o)
            }
        }

        if (dogmatic.empty) {
            // No dogmatic opinions: Compute fusion using Equation 16 of Jøsang’s paper
            val productOfUncertainties = opinions.map[o | o.uncertainty].reduce[acc, u | acc * u]

            var double numerator = 0.0
            var double beliefAccumulator = 0.0
            var double disbeliefAccumulator = 0.0

            // Compute belief fusion values
            for (o : opinions) {
                val productWithoutO = productOfUncertainties / o.uncertainty
                beliefAccumulator += productWithoutO * o.belief
                disbeliefAccumulator += productWithoutO * o.disbelief
                numerator += productWithoutO
            }

            numerator -= (opinions.size - 1) * productOfUncertainties

            resultBelief = beliefAccumulator / numerator
            resultDisbelief = disbeliefAccumulator / numerator
            resultUncertainty = productOfUncertainties / numerator
            resultRelativeWeight = 0.0
        } else {
            // At least 1 dogmatic opinion: Compute fusion using Equation 17
            val totalWeight = dogmatic.map[o | o.getRelativeWeight].reduce[acc, v | acc + v]

            resultBelief = dogmatic.map[o | o.getRelativeWeight / totalWeight * o.belief].reduce[acc, v | acc + v]
            resultDisbelief = dogmatic.map[o | o.getRelativeWeight / totalWeight * o.disbelief].reduce[acc, v | acc + v]
            resultUncertainty = 0.0
            resultRelativeWeight = totalWeight
        }

		
	    return "(" + resultBelief + 
	           ", " + resultDisbelief +
	           ", " + resultUncertainty +
	           ", " + resultAtomicity + ")"
	}
	
	/** Fusion Operator: Averaging Belief Fusion (ABF) **/
	def static String computeAveragingBF(Collection<SBoolean> opinions) {
	    // Check for null or empty collections
	    if (opinions === null || opinions.contains(null) || opinions.empty) {
	        throw new IllegalArgumentException("AVF: Cannot average null opinions")
	    }
	
	    var double b = 0.0
	    var double u = 0.0
	    var double a = 0.0
	    var double PU = 1.0
	    var int count = 0
	
	    // Compute product of all uncertainties
	    PU = opinions.map[it.uncertainty].reduce[acc, v | acc * v]
	
	    // Case I: All opinions have uncertainty > 0
	    if (PU != 0.0) {
	        for (o : opinions) {
	            u += PU / o.uncertainty
	            b += o.belief * (PU / o.uncertainty)
	            a += o.baseRate
	        }
	        val oBelief = b / u
	        val oAtomicity = a / opinions.size
	        val oUncertainty = opinions.size * PU / u
	        val oDisbelief = 1.0 - oBelief - oUncertainty
	        
	        return "(" + oBelief + 
	           ", " + oDisbelief +
	           ", " + oUncertainty +
	           ", " + oAtomicity + ")"
	           
	    } else {
	        // Case II: At least one opinion has uncertainty = 0, so we only consider those
	        for (o : opinions.filter[it.uncertainty == 0.0]) {
	            b += o.belief
	            a += o.baseRate
	            count++
	        }
	        val oBelief = b / count
	        val oAtomicity = a / count
	        val oUncertainty = 0.0
	        val oDisbelief = 1.0 - oBelief - oUncertainty
	        
			return "(" + round(oBelief) + 
	           ", " + round(oDisbelief) +
	           ", " + round(oUncertainty) +
	           ", " + round(oAtomicity) + ")"
	    }
	}
	
	def static double getRelativeWeight(SBoolean t) {
        return t.isDogmatic? 1.0D : 0.0D;
    }
    
    def static boolean isDogmatic(SBoolean t) {
	    return t.uncertainty == 0.0D;
	}

}
