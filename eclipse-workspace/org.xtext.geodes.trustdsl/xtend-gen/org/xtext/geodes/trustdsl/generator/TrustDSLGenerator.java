/**
 * generated by Xtext 2.37.0
 */
package org.xtext.geodes.trustdsl.generator;

import com.google.common.collect.Iterators;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.DoubleExtensions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.geodes.trustdsl.trustDSL.Belief;
import org.xtext.geodes.trustdsl.trustDSL.SBoolean;
import org.xtext.geodes.trustdsl.trustDSL.TrustDSLFactory;
import org.xtext.geodes.trustdsl.trustDSL.UncertainElement;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class TrustDSLGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final StringBuilder sb = new StringBuilder();
    List<UncertainElement> _list = IteratorExtensions.<UncertainElement>toList(Iterators.<UncertainElement>filter(resource.getAllContents(), UncertainElement.class));
    for (final UncertainElement element : _list) {
      sb.append(this.generateFusionElement(element));
    }
    fsa.generateFile("generated.trustdsl", sb.toString());
  }

  public String generateFusionElement(final UncertainElement element) {
    final StringBuilder sb = new StringBuilder();
    String _name = element.getName();
    final String fusionName = (_name + "_Fusion");
    final Function1<Belief, SBoolean> _function = (Belief it) -> {
      return it.getOpinion();
    };
    final List<SBoolean> beliefs = IterableExtensions.<SBoolean>toList(ListExtensions.<Belief, SBoolean>map(element.getBeliefs(), _function));
    sb.append((("UncertainElementFusion " + fusionName) + " {"));
    sb.append("\n    beliefs {");
    EList<Belief> _beliefs = element.getBeliefs();
    for (final Belief belief : _beliefs) {
      String _name_1 = belief.getName();
      String _plus = ("\n        Belief " + _name_1);
      String _plus_1 = (_plus + " (");
      String _name_2 = belief.getAgent().getName();
      String _plus_2 = (_plus_1 + _name_2);
      String _plus_3 = (_plus_2 + ", ");
      String _formatSBoolean = TrustDSLGenerator.formatSBoolean(belief.getOpinion());
      String _plus_4 = (_plus_3 + _formatSBoolean);
      String _plus_5 = (_plus_4 + "),");
      sb.append(_plus_5);
    }
    int _length = sb.length();
    int _minus = (_length - 1);
    sb.deleteCharAt(_minus);
    sb.append("\n    }");
    final String aleatoryCumulativeBF = TrustDSLGenerator.computeAleatoryCumulativeBF(beliefs);
    final String averagingBF = TrustDSLGenerator.computeAveragingBF(beliefs);
    final String beliefConstraintFusion = TrustDSLGenerator.computeBeliefConstraintFusion(beliefs);
    final String epistemicCumulativeBF = TrustDSLGenerator.computeEpistemicCumulativeBF(beliefs);
    final String weightedBF = TrustDSLGenerator.computeWeightedBF(beliefs);
    sb.append(("\n    aleatoryCumulativeBF = " + aleatoryCumulativeBF));
    sb.append(("\n    averageingBF = " + averagingBF));
    sb.append(("\n    beliefConstraintFusion = " + beliefConstraintFusion));
    sb.append(("\n    epistemicCumulativeBF = " + epistemicCumulativeBF));
    sb.append(("\n    weightedBF = " + weightedBF));
    sb.append("\n}\n\n");
    return sb.toString();
  }

  public static String formatSBoolean(final SBoolean sBoolean) {
    double _round = TrustDSLGenerator.round(sBoolean.getBelief());
    String _plus = ("(" + Double.valueOf(_round));
    String _plus_1 = (_plus + ", ");
    double _round_1 = TrustDSLGenerator.round(sBoolean.getDisbelief());
    String _plus_2 = (_plus_1 + Double.valueOf(_round_1));
    String _plus_3 = (_plus_2 + ", ");
    double _round_2 = TrustDSLGenerator.round(sBoolean.getUncertainty());
    String _plus_4 = (_plus_3 + Double.valueOf(_round_2));
    String _plus_5 = (_plus_4 + ", ");
    double _round_3 = TrustDSLGenerator.round(sBoolean.getBaseRate());
    String _plus_6 = (_plus_5 + Double.valueOf(_round_3));
    return (_plus_6 + ")");
  }

  public static double round(final double value) {
    return BigDecimal.valueOf(value).setScale(3, RoundingMode.HALF_UP).doubleValue();
  }

  /**
   * Fusion Operator: Aleatory Cumulative Belief Fusion (ACBF)
   */
  public static String computeAleatoryCumulativeBF(final Collection<SBoolean> opinions) {
    if ((((opinions == null) || opinions.contains(null)) || opinions.isEmpty())) {
      throw new IllegalArgumentException("aCBF: Cannot average null opinions");
    }
    int _size = opinions.size();
    boolean _equals = (_size == 1);
    if (_equals) {
      return opinions.iterator().next().toString();
    }
    double resultBelief = 0.0;
    double resultDisbelief = 0.0;
    double resultUncertainty = 0.0;
    double resultAtomicity = (-1.0);
    int _size_1 = opinions.size();
    final ArrayList<SBoolean> dogmatic = new ArrayList<SBoolean>(_size_1);
    final Iterator<SBoolean> it = opinions.iterator();
    boolean first = true;
    while (it.hasNext()) {
      {
        final SBoolean o = it.next();
        if (first) {
          resultAtomicity = o.getBaseRate();
          first = false;
        }
        double _uncertainty = o.getUncertainty();
        boolean _equals_1 = (_uncertainty == 0.0);
        if (_equals_1) {
          dogmatic.add(o);
        }
      }
    }
    boolean _isEmpty = dogmatic.isEmpty();
    if (_isEmpty) {
      final Function1<SBoolean, Double> _function = (SBoolean o) -> {
        return Double.valueOf(o.getUncertainty());
      };
      final Function2<Double, Double, Double> _function_1 = (Double acc, Double u) -> {
        return Double.valueOf(DoubleExtensions.operator_multiply(acc, u));
      };
      final Double productOfUncertainties = IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(opinions, _function), _function_1);
      double numerator = 0.0;
      double beliefAccumulator = 0.0;
      double disbeliefAccumulator = 0.0;
      for (final SBoolean o : opinions) {
        {
          double _uncertainty = o.getUncertainty();
          final double productWithoutO = ((productOfUncertainties).doubleValue() / _uncertainty);
          double _beliefAccumulator = beliefAccumulator;
          double _belief = o.getBelief();
          double _multiply = (productWithoutO * _belief);
          beliefAccumulator = (_beliefAccumulator + _multiply);
          double _disbeliefAccumulator = disbeliefAccumulator;
          double _disbelief = o.getDisbelief();
          double _multiply_1 = (productWithoutO * _disbelief);
          disbeliefAccumulator = (_disbeliefAccumulator + _multiply_1);
          double _numerator = numerator;
          numerator = (_numerator + productWithoutO);
        }
      }
      double _numerator = numerator;
      int _size_2 = opinions.size();
      int _minus = (_size_2 - 1);
      double _multiply = (_minus * (productOfUncertainties).doubleValue());
      numerator = (_numerator - _multiply);
      resultBelief = (beliefAccumulator / numerator);
      resultDisbelief = (disbeliefAccumulator / numerator);
      resultUncertainty = ((productOfUncertainties).doubleValue() / numerator);
    } else {
      final Function1<SBoolean, Double> _function_2 = (SBoolean o_1) -> {
        return Double.valueOf(TrustDSLGenerator.getRelativeWeight(o_1));
      };
      final Function2<Double, Double, Double> _function_3 = (Double acc, Double v) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
      };
      final Double totalWeight = IterableExtensions.<Double>reduce(ListExtensions.<SBoolean, Double>map(dogmatic, _function_2), _function_3);
      final Function1<SBoolean, Double> _function_4 = (SBoolean o_1) -> {
        double _relativeWeight = TrustDSLGenerator.getRelativeWeight(o_1);
        double _divide = (_relativeWeight / (totalWeight).doubleValue());
        double _belief = o_1.getBelief();
        return Double.valueOf((_divide * _belief));
      };
      final Function2<Double, Double, Double> _function_5 = (Double acc, Double v) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
      };
      resultBelief = (IterableExtensions.<Double>reduce(ListExtensions.<SBoolean, Double>map(dogmatic, _function_4), _function_5)).doubleValue();
      final Function1<SBoolean, Double> _function_6 = (SBoolean o_1) -> {
        double _relativeWeight = TrustDSLGenerator.getRelativeWeight(o_1);
        double _divide = (_relativeWeight / (totalWeight).doubleValue());
        double _disbelief = o_1.getDisbelief();
        return Double.valueOf((_divide * _disbelief));
      };
      final Function2<Double, Double, Double> _function_7 = (Double acc, Double v) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
      };
      resultDisbelief = (IterableExtensions.<Double>reduce(ListExtensions.<SBoolean, Double>map(dogmatic, _function_6), _function_7)).doubleValue();
      resultUncertainty = 0.0;
    }
    double _round = TrustDSLGenerator.round(resultBelief);
    String _plus = ("(" + Double.valueOf(_round));
    String _plus_1 = (_plus + 
      ", ");
    double _round_1 = TrustDSLGenerator.round(resultDisbelief);
    String _plus_2 = (_plus_1 + Double.valueOf(_round_1));
    String _plus_3 = (_plus_2 + 
      ", ");
    double _round_2 = TrustDSLGenerator.round(resultUncertainty);
    String _plus_4 = (_plus_3 + Double.valueOf(_round_2));
    String _plus_5 = (_plus_4 + 
      ", ");
    double _round_3 = TrustDSLGenerator.round(resultAtomicity);
    String _plus_6 = (_plus_5 + Double.valueOf(_round_3));
    return (_plus_6 + ")");
  }

  /**
   * Fusion Operator: Averaging Belief Fusion (ABF)
   */
  public static String computeAveragingBF(final Collection<SBoolean> opinions) {
    if ((((opinions == null) || opinions.contains(null)) || opinions.isEmpty())) {
      throw new IllegalArgumentException("AVF: Cannot average null opinions");
    }
    double b = 0.0;
    double u = 0.0;
    double a = 0.0;
    double PU = 1.0;
    int count = 0;
    final Function1<SBoolean, Double> _function = (SBoolean it) -> {
      return Double.valueOf(it.getUncertainty());
    };
    final Function2<Double, Double, Double> _function_1 = (Double acc, Double v) -> {
      return Double.valueOf(DoubleExtensions.operator_multiply(acc, v));
    };
    PU = (IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(opinions, _function), _function_1)).doubleValue();
    if ((PU != 0.0)) {
      for (final SBoolean o : opinions) {
        {
          double _u = u;
          double _uncertainty = o.getUncertainty();
          double _divide = (PU / _uncertainty);
          u = (_u + _divide);
          double _b = b;
          double _belief = o.getBelief();
          double _uncertainty_1 = o.getUncertainty();
          double _divide_1 = (PU / _uncertainty_1);
          double _multiply = (_belief * _divide_1);
          b = (_b + _multiply);
          double _a = a;
          double _baseRate = o.getBaseRate();
          a = (_a + _baseRate);
        }
      }
      final double oBelief = (b / u);
      int _size = opinions.size();
      final double oAtomicity = (a / _size);
      int _size_1 = opinions.size();
      double _multiply = (_size_1 * PU);
      final double oUncertainty = (_multiply / u);
      final double oDisbelief = ((1.0 - oBelief) - oUncertainty);
      double _round = TrustDSLGenerator.round(oBelief);
      String _plus = ("(" + Double.valueOf(_round));
      String _plus_1 = (_plus + 
        ", ");
      double _round_1 = TrustDSLGenerator.round(oDisbelief);
      String _plus_2 = (_plus_1 + Double.valueOf(_round_1));
      String _plus_3 = (_plus_2 + 
        ", ");
      double _round_2 = TrustDSLGenerator.round(oUncertainty);
      String _plus_4 = (_plus_3 + Double.valueOf(_round_2));
      String _plus_5 = (_plus_4 + 
        ", ");
      double _round_3 = TrustDSLGenerator.round(oAtomicity);
      String _plus_6 = (_plus_5 + Double.valueOf(_round_3));
      return (_plus_6 + ")");
    } else {
      final Function1<SBoolean, Boolean> _function_2 = (SBoolean it) -> {
        double _uncertainty = it.getUncertainty();
        return Boolean.valueOf((_uncertainty == 0.0));
      };
      Iterable<SBoolean> _filter = IterableExtensions.<SBoolean>filter(opinions, _function_2);
      for (final SBoolean o_1 : _filter) {
        {
          double _b = b;
          double _belief = o_1.getBelief();
          b = (_b + _belief);
          double _a = a;
          double _baseRate = o_1.getBaseRate();
          a = (_a + _baseRate);
          count++;
        }
      }
      final double oBelief_1 = (b / count);
      final double oAtomicity_1 = (a / count);
      final double oUncertainty_1 = 0.0;
      final double oDisbelief_1 = ((1.0 - oBelief_1) - oUncertainty_1);
      double _round_4 = TrustDSLGenerator.round(oBelief_1);
      String _plus_7 = ("(" + Double.valueOf(_round_4));
      String _plus_8 = (_plus_7 + 
        ", ");
      double _round_5 = TrustDSLGenerator.round(oDisbelief_1);
      String _plus_9 = (_plus_8 + Double.valueOf(_round_5));
      String _plus_10 = (_plus_9 + 
        ", ");
      double _round_6 = TrustDSLGenerator.round(oUncertainty_1);
      String _plus_11 = (_plus_10 + Double.valueOf(_round_6));
      String _plus_12 = (_plus_11 + 
        ", ");
      double _round_7 = TrustDSLGenerator.round(oAtomicity_1);
      String _plus_13 = (_plus_12 + Double.valueOf(_round_7));
      return (_plus_13 + ")");
    }
  }

  /**
   * Fusion Operator: Belief Constraint Fusion (BCF)
   */
  public static String computeBeliefConstraintFusion(final Collection<SBoolean> opinions) {
    if ((opinions.contains(null) || (opinions.size() < 2))) {
      throw new IllegalArgumentException("BCF: Cannot fuse null opinions, or only one opinion was passed");
    }
    SBoolean bcf = null;
    for (final SBoolean so : opinions) {
      {
        if ((bcf == null)) {
          bcf = so;
        } else {
          bcf = TrustDSLGenerator.bcFusion(bcf, so);
        }
        if ((bcf == null)) {
          return TrustDSLGenerator.formatSBoolean(bcf);
        }
      }
    }
    return TrustDSLGenerator.formatSBoolean(bcf);
  }

  /**
   * Fusion Operator: Epistemic Cumulative Belief Fusion (ECBF)
   */
  public static String computeEpistemicCumulativeBF(final Collection<SBoolean> opinions) {
    if ((((opinions == null) || opinions.contains(null)) || opinions.isEmpty())) {
      throw new IllegalArgumentException("eCBF: Cannot average null opinions");
    }
    int _size = opinions.size();
    boolean _equals = (_size == 1);
    if (_equals) {
      return TrustDSLGenerator.formatSBoolean(TrustDSLGenerator.uncertaintyMaximized(opinions.iterator().next()));
    }
    double resultBelief = 0.0;
    double resultDisbelief = 0.0;
    double resultUncertainty = 0.0;
    double resultAtomicity = (-1.0);
    final ArrayList<SBoolean> dogmatic = CollectionLiterals.<SBoolean>newArrayList();
    final Iterator<SBoolean> iterator = opinions.iterator();
    boolean first = true;
    while (iterator.hasNext()) {
      {
        final SBoolean o = iterator.next();
        if (first) {
          resultAtomicity = o.getBaseRate();
          first = false;
        }
        double _uncertainty = o.getUncertainty();
        boolean _equals_1 = (_uncertainty == 0.0);
        if (_equals_1) {
          dogmatic.add(o);
        }
      }
    }
    boolean _isEmpty = dogmatic.isEmpty();
    if (_isEmpty) {
      final Function1<SBoolean, Double> _function = (SBoolean o) -> {
        return Double.valueOf(o.getUncertainty());
      };
      final Function2<Double, Double, Double> _function_1 = (Double acc, Double u) -> {
        return Double.valueOf(DoubleExtensions.operator_multiply(acc, u));
      };
      final Double productOfUncertainties = IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(opinions, _function), _function_1);
      double numerator = 0.0;
      double beliefAccumulator = 0.0;
      double disbeliefAccumulator = 0.0;
      for (final SBoolean o : opinions) {
        {
          double _uncertainty = o.getUncertainty();
          final double productWithoutO = ((productOfUncertainties).doubleValue() / _uncertainty);
          double _beliefAccumulator = beliefAccumulator;
          double _belief = o.getBelief();
          double _multiply = (productWithoutO * _belief);
          beliefAccumulator = (_beliefAccumulator + _multiply);
          double _disbeliefAccumulator = disbeliefAccumulator;
          double _disbelief = o.getDisbelief();
          double _multiply_1 = (productWithoutO * _disbelief);
          disbeliefAccumulator = (_disbeliefAccumulator + _multiply_1);
          double _numerator = numerator;
          numerator = (_numerator + productWithoutO);
        }
      }
      double _numerator = numerator;
      int _size_1 = opinions.size();
      int _minus = (_size_1 - 1);
      double _multiply = (_minus * (productOfUncertainties).doubleValue());
      numerator = (_numerator - _multiply);
      resultBelief = (beliefAccumulator / numerator);
      resultDisbelief = (disbeliefAccumulator / numerator);
      resultUncertainty = ((productOfUncertainties).doubleValue() / numerator);
    } else {
      final Function1<SBoolean, Double> _function_2 = (SBoolean o_1) -> {
        return Double.valueOf(TrustDSLGenerator.getRelativeWeight(o_1));
      };
      final Function2<Double, Double, Double> _function_3 = (Double acc, Double w) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, w));
      };
      final Double totalWeight = IterableExtensions.<Double>reduce(ListExtensions.<SBoolean, Double>map(dogmatic, _function_2), _function_3);
      final Function1<SBoolean, Double> _function_4 = (SBoolean o_1) -> {
        double _relativeWeight = TrustDSLGenerator.getRelativeWeight(o_1);
        double _divide = (_relativeWeight / (totalWeight).doubleValue());
        double _belief = o_1.getBelief();
        return Double.valueOf((_divide * _belief));
      };
      final Function2<Double, Double, Double> _function_5 = (Double acc, Double v) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
      };
      resultBelief = (IterableExtensions.<Double>reduce(ListExtensions.<SBoolean, Double>map(dogmatic, _function_4), _function_5)).doubleValue();
      final Function1<SBoolean, Double> _function_6 = (SBoolean o_1) -> {
        double _relativeWeight = TrustDSLGenerator.getRelativeWeight(o_1);
        double _divide = (_relativeWeight / (totalWeight).doubleValue());
        double _disbelief = o_1.getDisbelief();
        return Double.valueOf((_divide * _disbelief));
      };
      final Function2<Double, Double, Double> _function_7 = (Double acc, Double v) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
      };
      resultDisbelief = (IterableExtensions.<Double>reduce(ListExtensions.<SBoolean, Double>map(dogmatic, _function_6), _function_7)).doubleValue();
      resultUncertainty = 0.0;
    }
    final SBoolean result = TrustDSLGenerator.createSBoolean(resultBelief, resultDisbelief, resultUncertainty, resultAtomicity);
    return TrustDSLGenerator.formatSBoolean(TrustDSLGenerator.uncertaintyMaximized(result));
  }

  /**
   * Fusion Operator: Weighted Belief Fusion (WBF)
   */
  public static String computeWeightedBF(final Collection<SBoolean> opinions) {
    if ((((opinions == null) || opinions.contains(null)) || opinions.isEmpty())) {
      throw new IllegalArgumentException("WBF: Cannot average null opinions");
    }
    int _size = opinions.size();
    boolean _equals = (_size == 1);
    if (_equals) {
      return TrustDSLGenerator.formatSBoolean(opinions.iterator().next());
    }
    double resultBelief = 0.0;
    double resultDisbelief = 0.0;
    double resultUncertainty = 0.0;
    double resultAtomicity = (-1.0);
    final Function1<SBoolean, Boolean> _function = (SBoolean o) -> {
      double _uncertainty = o.getUncertainty();
      return Boolean.valueOf((_uncertainty == 0.0));
    };
    final Iterable<SBoolean> dogmatic = IterableExtensions.<SBoolean>filter(opinions, _function);
    if ((IterableExtensions.isEmpty(dogmatic) && IterableExtensions.<SBoolean>exists(opinions, ((Function1<SBoolean, Boolean>) (SBoolean o) -> {
      double _certainty = TrustDSLGenerator.certainty(o);
      return Boolean.valueOf((_certainty > 0.0));
    })))) {
      final Function1<SBoolean, Double> _function_1 = (SBoolean o) -> {
        return Double.valueOf(o.getUncertainty());
      };
      final Function2<Double, Double, Double> _function_2 = (Double acc, Double u) -> {
        return Double.valueOf(DoubleExtensions.operator_multiply(acc, u));
      };
      final Double productOfUncertainties = IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(opinions, _function_1), _function_2);
      final Function1<SBoolean, Double> _function_3 = (SBoolean o) -> {
        return Double.valueOf(o.getUncertainty());
      };
      final Function2<Double, Double, Double> _function_4 = (Double acc, Double u) -> {
        return Double.valueOf(DoubleExtensions.operator_plus(acc, u));
      };
      final Double sumOfUncertainties = IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(opinions, _function_3), _function_4);
      double numerator = 0.0;
      double beliefAccumulator = 0.0;
      double disbeliefAccumulator = 0.0;
      double atomicityAccumulator = 0.0;
      for (final SBoolean o : opinions) {
        {
          double _uncertainty = o.getUncertainty();
          final double prod = ((productOfUncertainties).doubleValue() / _uncertainty);
          double _beliefAccumulator = beliefAccumulator;
          double _belief = o.getBelief();
          double _multiply = (prod * _belief);
          double _certainty = TrustDSLGenerator.certainty(o);
          double _multiply_1 = (_multiply * _certainty);
          beliefAccumulator = (_beliefAccumulator + _multiply_1);
          double _disbeliefAccumulator = disbeliefAccumulator;
          double _disbelief = o.getDisbelief();
          double _multiply_2 = (prod * _disbelief);
          double _certainty_1 = TrustDSLGenerator.certainty(o);
          double _multiply_3 = (_multiply_2 * _certainty_1);
          disbeliefAccumulator = (_disbeliefAccumulator + _multiply_3);
          double _atomicityAccumulator = atomicityAccumulator;
          double _baseRate = o.getBaseRate();
          double _certainty_2 = TrustDSLGenerator.certainty(o);
          double _multiply_4 = (_baseRate * _certainty_2);
          atomicityAccumulator = (_atomicityAccumulator + _multiply_4);
          double _numerator = numerator;
          numerator = (_numerator + prod);
        }
      }
      double _numerator = numerator;
      int _size_1 = opinions.size();
      double _multiply = (_size_1 * (productOfUncertainties).doubleValue());
      numerator = (_numerator - _multiply);
      resultBelief = (beliefAccumulator / numerator);
      resultDisbelief = (disbeliefAccumulator / numerator);
      int _size_2 = opinions.size();
      double _minus = (_size_2 - (sumOfUncertainties).doubleValue());
      double _multiply_1 = (_minus * (productOfUncertainties).doubleValue());
      double _divide = (_multiply_1 / numerator);
      resultUncertainty = _divide;
      int _size_3 = opinions.size();
      double _minus_1 = (_size_3 - (sumOfUncertainties).doubleValue());
      double _divide_1 = (atomicityAccumulator / _minus_1);
      resultAtomicity = _divide_1;
    } else {
      final Function1<SBoolean, Boolean> _function_5 = (SBoolean o_1) -> {
        double _uncertainty = o_1.getUncertainty();
        return Boolean.valueOf((_uncertainty == 1.0));
      };
      boolean _forall = IterableExtensions.<SBoolean>forall(opinions, _function_5);
      if (_forall) {
        resultBelief = 0.0;
        resultDisbelief = 0.0;
        resultUncertainty = 1.0;
        final Function1<SBoolean, Double> _function_6 = (SBoolean o_1) -> {
          return Double.valueOf(o_1.getBaseRate());
        };
        final Function2<Double, Double, Double> _function_7 = (Double acc, Double v) -> {
          return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
        };
        Double _reduce = IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(opinions, _function_6), _function_7);
        int _size_4 = opinions.size();
        double _divide_2 = ((_reduce).doubleValue() / _size_4);
        resultAtomicity = _divide_2;
      } else {
        final Function1<SBoolean, Double> _function_8 = (SBoolean o_1) -> {
          return Double.valueOf(TrustDSLGenerator.getRelativeWeight(o_1));
        };
        final Function2<Double, Double, Double> _function_9 = (Double acc, Double w) -> {
          return Double.valueOf(DoubleExtensions.operator_plus(acc, w));
        };
        final Double totalWeight = IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(dogmatic, _function_8), _function_9);
        final Function1<SBoolean, Double> _function_10 = (SBoolean o_1) -> {
          double _relativeWeight = TrustDSLGenerator.getRelativeWeight(o_1);
          double _divide_3 = (_relativeWeight / (totalWeight).doubleValue());
          double _belief = o_1.getBelief();
          return Double.valueOf((_divide_3 * _belief));
        };
        final Function2<Double, Double, Double> _function_11 = (Double acc, Double v) -> {
          return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
        };
        resultBelief = (IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(dogmatic, _function_10), _function_11)).doubleValue();
        final Function1<SBoolean, Double> _function_12 = (SBoolean o_1) -> {
          double _relativeWeight = TrustDSLGenerator.getRelativeWeight(o_1);
          double _divide_3 = (_relativeWeight / (totalWeight).doubleValue());
          double _disbelief = o_1.getDisbelief();
          return Double.valueOf((_divide_3 * _disbelief));
        };
        final Function2<Double, Double, Double> _function_13 = (Double acc, Double v) -> {
          return Double.valueOf(DoubleExtensions.operator_plus(acc, v));
        };
        resultDisbelief = (IterableExtensions.<Double>reduce(IterableExtensions.<SBoolean, Double>map(dogmatic, _function_12), _function_13)).doubleValue();
        resultUncertainty = 0.0;
        resultAtomicity = IterableExtensions.<SBoolean>head(opinions).getBaseRate();
      }
    }
    return TrustDSLGenerator.formatSBoolean(TrustDSLGenerator.createSBoolean(resultBelief, resultDisbelief, resultUncertainty, resultAtomicity));
  }

  public static SBoolean uncertaintyMaximized(final SBoolean sBoolean) {
    final double p = TrustDSLGenerator.projection(sBoolean);
    if (((((sBoolean.getBaseRate() == 1.0) && (p == 1.0)) || ((sBoolean.getBaseRate() == 1.0) && (sBoolean.getUncertainty() == 1.0))) || ((sBoolean.getBaseRate() == 0.0) && (sBoolean.getBelief() == 0.0)))) {
      return TrustDSLGenerator.createSBoolean(0.0, 0.0, 1.0, sBoolean.getBaseRate());
    }
    double _baseRate = sBoolean.getBaseRate();
    boolean _lessThan = (p < _baseRate);
    if (_lessThan) {
      double _baseRate_1 = sBoolean.getBaseRate();
      double _divide = (p / _baseRate_1);
      double _minus = (1.0 - _divide);
      double _baseRate_2 = sBoolean.getBaseRate();
      double _divide_1 = (p / _baseRate_2);
      return TrustDSLGenerator.createSBoolean(0.0, _minus, _divide_1, sBoolean.getBaseRate());
    }
    double _baseRate_3 = sBoolean.getBaseRate();
    double _minus_1 = (p - _baseRate_3);
    double _baseRate_4 = sBoolean.getBaseRate();
    double _minus_2 = (1.0 - _baseRate_4);
    double _divide_2 = (_minus_1 / _minus_2);
    double _baseRate_5 = sBoolean.getBaseRate();
    double _minus_3 = (1.0 - _baseRate_5);
    double _divide_3 = ((1.0 - p) / _minus_3);
    return TrustDSLGenerator.createSBoolean(_divide_2, 0.0, _divide_3, sBoolean.getBaseRate());
  }

  public static SBoolean createSBoolean(final double b, final double d, final double u, final double a) {
    final SBoolean result = TrustDSLFactory.eINSTANCE.createSBoolean();
    result.setBelief(b);
    result.setDisbelief(d);
    result.setUncertainty(u);
    result.setBaseRate(a);
    return result;
  }

  public static final SBoolean bcFusion(final SBoolean bcf, final SBoolean opinion) {
    double _belief = bcf.getBelief();
    double _uncertainty = opinion.getUncertainty();
    double _multiply = (_belief * _uncertainty);
    double _uncertainty_1 = bcf.getUncertainty();
    double _belief_1 = opinion.getBelief();
    double _multiply_1 = (_uncertainty_1 * _belief_1);
    double _plus = (_multiply + _multiply_1);
    double _belief_2 = bcf.getBelief();
    double _belief_3 = opinion.getBelief();
    double _multiply_2 = (_belief_2 * _belief_3);
    final double harmony = (_plus + _multiply_2);
    double _belief_4 = bcf.getBelief();
    double _disbelief = opinion.getDisbelief();
    double _multiply_3 = (_belief_4 * _disbelief);
    double _disbelief_1 = bcf.getDisbelief();
    double _belief_5 = opinion.getBelief();
    double _multiply_4 = (_disbelief_1 * _belief_5);
    final double conflict = (_multiply_3 + _multiply_4);
    if ((conflict == 1.0)) {
      return null;
    }
    final double b = (harmony / (1.0 - conflict));
    double _uncertainty_2 = bcf.getUncertainty();
    double _uncertainty_3 = opinion.getUncertainty();
    double _multiply_5 = (_uncertainty_2 * _uncertainty_3);
    final double u = (_multiply_5 / (1.0 - conflict));
    double _xifexpression = (double) 0;
    double _uncertainty_4 = bcf.getUncertainty();
    double _uncertainty_5 = opinion.getUncertainty();
    double _plus_1 = (_uncertainty_4 + _uncertainty_5);
    boolean _equals = (_plus_1 == 2.0);
    if (_equals) {
      double _baseRate = bcf.getBaseRate();
      double _baseRate_1 = opinion.getBaseRate();
      double _plus_2 = (_baseRate + _baseRate_1);
      _xifexpression = (_plus_2 / 2.0);
    } else {
      double _baseRate_2 = bcf.getBaseRate();
      double _uncertainty_6 = bcf.getUncertainty();
      double _minus = (1.0 - _uncertainty_6);
      double _multiply_6 = (_baseRate_2 * _minus);
      double _baseRate_3 = opinion.getBaseRate();
      double _uncertainty_7 = opinion.getUncertainty();
      double _minus_1 = (1.0 - _uncertainty_7);
      double _multiply_7 = (_baseRate_3 * _minus_1);
      double _plus_3 = (_multiply_6 + _multiply_7);
      double _uncertainty_8 = bcf.getUncertainty();
      double _minus_2 = (2 - _uncertainty_8);
      double _uncertainty_9 = opinion.getUncertainty();
      double _minus_3 = (_minus_2 - _uncertainty_9);
      _xifexpression = (_plus_3 / _minus_3);
    }
    final double a = _xifexpression;
    final SBoolean result = TrustDSLFactory.eINSTANCE.createSBoolean();
    result.setBelief(b);
    result.setDisbelief(((1.0 - b) - u));
    result.setUncertainty(u);
    result.setBaseRate(a);
    return result;
  }

  public static double getRelativeWeight(final SBoolean t) {
    double _xifexpression = (double) 0;
    boolean _isDogmatic = TrustDSLGenerator.isDogmatic(t);
    if (_isDogmatic) {
      _xifexpression = 1.0D;
    } else {
      _xifexpression = 0.0D;
    }
    return _xifexpression;
  }

  public static boolean isDogmatic(final SBoolean t) {
    double _uncertainty = t.getUncertainty();
    return (_uncertainty == 0.0D);
  }

  public static double projection(final SBoolean sBoolean) {
    double _belief = sBoolean.getBelief();
    double _baseRate = sBoolean.getBaseRate();
    double _uncertainty = sBoolean.getUncertainty();
    double _multiply = (_baseRate * _uncertainty);
    double _plus = (_belief + _multiply);
    return TrustDSLGenerator.adjust(_plus);
  }

  private static double adjust(final double value) {
    long _round = Math.round((value * 1000000.0));
    return (_round / 1000000.0);
  }

  private static double certainty(final SBoolean sBoolean) {
    double _uncertainty = sBoolean.getUncertainty();
    boolean _equals = (_uncertainty == (0.0D / 0.0D));
    if (_equals) {
      return (0.0D / 0.0D);
    }
    double _uncertainty_1 = sBoolean.getUncertainty();
    return (1.0D - _uncertainty_1);
  }
}
