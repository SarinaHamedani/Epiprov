/*
 * generated by Xtext 2.37.0
 */
package org.w3.ns.prov.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.w3.ns.prov.provN.Activity;
import org.w3.ns.prov.provN.Agent;
import org.w3.ns.prov.provN.Attribute;
import org.w3.ns.prov.provN.DateTime;
import org.w3.ns.prov.provN.Document;
import org.w3.ns.prov.provN.Entity;
import org.w3.ns.prov.provN.HadMember;
import org.w3.ns.prov.provN.Model;
import org.w3.ns.prov.provN.Namespace;
import org.w3.ns.prov.provN.ProvNPackage;
import org.w3.ns.prov.provN.Used;
import org.w3.ns.prov.provN.WasAssociatedWith;
import org.w3.ns.prov.provN.WasAttributedTo;
import org.w3.ns.prov.provN.WasDerivedFrom;
import org.w3.ns.prov.provN.WasGeneratedBy;
import org.w3.ns.prov.services.ProvNGrammarAccess;

@SuppressWarnings("all")
public class ProvNSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ProvNGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ProvNPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProvNPackage.ACTIVITY:
				sequence_Activity(context, (Activity) semanticObject); 
				return; 
			case ProvNPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case ProvNPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ProvNPackage.DATE_TIME:
				sequence_DateTime(context, (DateTime) semanticObject); 
				return; 
			case ProvNPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case ProvNPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case ProvNPackage.HAD_MEMBER:
				sequence_HadMember(context, (HadMember) semanticObject); 
				return; 
			case ProvNPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ProvNPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case ProvNPackage.USED:
				sequence_Used(context, (Used) semanticObject); 
				return; 
			case ProvNPackage.WAS_ASSOCIATED_WITH:
				sequence_WasAssociatedWith(context, (WasAssociatedWith) semanticObject); 
				return; 
			case ProvNPackage.WAS_ATTRIBUTED_TO:
				sequence_WasAttributedTo(context, (WasAttributedTo) semanticObject); 
				return; 
			case ProvNPackage.WAS_DERIVED_FROM:
				sequence_WasDerivedFrom(context, (WasDerivedFrom) semanticObject); 
				return; 
			case ProvNPackage.WAS_GENERATED_BY:
				sequence_WasGeneratedBy(context, (WasGeneratedBy) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Activity
	 *     Activity returns Activity
	 *
	 * Constraint:
	 *     (name=QualifiedName startTime=DateTime? endTime=DateTime? (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_Activity(ISerializationContext context, Activity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Agent
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (name=QualifiedName (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (label=QualifiedName value=STRING)
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.ATTRIBUTE__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.ATTRIBUTE__LABEL));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getLabelQualifiedNameParserRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getAttributeAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DateTime returns DateTime
	 *
	 * Constraint:
	 *     (
	 *         year=INT 
	 *         month=INT 
	 *         day=INT 
	 *         hour=INT 
	 *         minute=INT 
	 *         second=INT
	 *     )
	 * </pre>
	 */
	protected void sequence_DateTime(ISerializationContext context, DateTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DATE_TIME__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DATE_TIME__YEAR));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DATE_TIME__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DATE_TIME__MONTH));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DATE_TIME__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DATE_TIME__DAY));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DATE_TIME__HOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DATE_TIME__HOUR));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DATE_TIME__MINUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DATE_TIME__MINUTE));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DATE_TIME__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DATE_TIME__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateTimeAccess().getYearINTTerminalRuleCall_0_0(), semanticObject.getYear());
		feeder.accept(grammarAccess.getDateTimeAccess().getMonthINTTerminalRuleCall_2_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getDateTimeAccess().getDayINTTerminalRuleCall_4_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getDateTimeAccess().getHourINTTerminalRuleCall_6_0(), semanticObject.getHour());
		feeder.accept(grammarAccess.getDateTimeAccess().getMinuteINTTerminalRuleCall_8_0(), semanticObject.getMinute());
		feeder.accept(grammarAccess.getDateTimeAccess().getSecondINTTerminalRuleCall_10_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Document returns Document
	 *
	 * Constraint:
	 *     compartmentalModel=Model
	 * </pre>
	 */
	protected void sequence_Document(ISerializationContext context, Document semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.DOCUMENT__COMPARTMENTAL_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.DOCUMENT__COMPARTMENTAL_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDocumentAccess().getCompartmentalModelModelParserRuleCall_1_0(), semanticObject.getCompartmentalModel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=QualifiedName (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns HadMember
	 *     Relation returns HadMember
	 *     HadMember returns HadMember
	 *
	 * Constraint:
	 *     (collection=[Entity|QualifiedName] member=[Entity|QualifiedName])
	 * </pre>
	 */
	protected void sequence_HadMember(ISerializationContext context, HadMember semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.HAD_MEMBER__COLLECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.HAD_MEMBER__COLLECTION));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.HAD_MEMBER__MEMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.HAD_MEMBER__MEMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHadMemberAccess().getCollectionEntityQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(ProvNPackage.Literals.HAD_MEMBER__COLLECTION, false));
		feeder.accept(grammarAccess.getHadMemberAccess().getMemberEntityQualifiedNameParserRuleCall_4_0_1(), semanticObject.eGet(ProvNPackage.Literals.HAD_MEMBER__MEMBER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (namespaces+=Namespace* statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Namespace returns Namespace
	 *
	 * Constraint:
	 *     (name=ID uri=URISTRING)
	 * </pre>
	 */
	protected void sequence_Namespace(ISerializationContext context, Namespace semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.NAMESPACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.NAMESPACE__NAME));
			if (transientValues.isValueTransient(semanticObject, ProvNPackage.Literals.NAMESPACE__URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProvNPackage.Literals.NAMESPACE__URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamespaceAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamespaceAccess().getUriURISTRINGTerminalRuleCall_3_0(), semanticObject.getUri());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Used
	 *     Relation returns Used
	 *     Used returns Used
	 *
	 * Constraint:
	 *     (activity=[Activity|QualifiedName] entity=[Entity|QualifiedName] time=DateTime? (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_Used(ISerializationContext context, Used semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WasAssociatedWith
	 *     Relation returns WasAssociatedWith
	 *     WasAssociatedWith returns WasAssociatedWith
	 *
	 * Constraint:
	 *     (activity=[Activity|QualifiedName] agent=[Agent|QualifiedName] plan=[Entity|ID]? (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_WasAssociatedWith(ISerializationContext context, WasAssociatedWith semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WasAttributedTo
	 *     Relation returns WasAttributedTo
	 *     WasAttributedTo returns WasAttributedTo
	 *
	 * Constraint:
	 *     (entity=[Entity|QualifiedName] agent=[Agent|QualifiedName] (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_WasAttributedTo(ISerializationContext context, WasAttributedTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WasDerivedFrom
	 *     Relation returns WasDerivedFrom
	 *     WasDerivedFrom returns WasDerivedFrom
	 *
	 * Constraint:
	 *     (generatedEntity=[Entity|QualifiedName] usedEntity=[Entity|QualifiedName] time=DateTime? (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_WasDerivedFrom(ISerializationContext context, WasDerivedFrom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WasGeneratedBy
	 *     Relation returns WasGeneratedBy
	 *     WasGeneratedBy returns WasGeneratedBy
	 *
	 * Constraint:
	 *     (entity=[Entity|QualifiedName] activity=[Activity|QualifiedName] time=DateTime? (attributes+=Attribute attributes+=Attribute*)?)
	 * </pre>
	 */
	protected void sequence_WasGeneratedBy(ISerializationContext context, WasGeneratedBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
